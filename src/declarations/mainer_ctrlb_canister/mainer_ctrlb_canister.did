type TimeInterval = variant {Daily;};
type StatusCodeRecordResult = 
 variant {
   Err: ApiError;
   Ok: StatusCodeRecord;
 };
type StatusCodeRecord = record {status_code: StatusCode;};
type StatusCode = nat16;
type StatisticsRetrievalResult = 
 variant {
   Err: ApiError;
   Ok: StatisticsRecord;
 };
type StatisticsRecord = 
 record {
   cycleBalance: nat;
   cyclesBurnRate: CyclesBurnRate;
   totalCyclesBurnt: nat;
 };
type SelectableMainerLLMs = variant {Qwen2_5_500M;};
type ProtocolCanisterType = 
 variant {
   Challenger;
   Judge;
   MainerAgent: MainerAgentCanisterType;
   MainerCreator;
   MainerLlm;
   Verifier;
 };
type OfficialMainerAgentCanister = 
 record {
   address: CanisterAddress;
   canisterType: ProtocolCanisterType;
   createdBy: principal;
   creationTimestamp: nat64;
   mainerConfig: MainerConfigurationInput;
   ownedBy: principal;
   status: CanisterStatus;
   subnet: text;
 };
type NatResult = 
 variant {
   Err: ApiError;
   Ok: nat;
 };
type MainerConfigurationInput = 
 record {
   cyclesForMainer: nat;
   mainerAgentCanisterType: MainerAgentCanisterType;
   selectedLLM: opt SelectableMainerLLMs;
   subnetCtrl: text;
   subnetLlm: text;
 };
type MainerAgentSettingsInput = record {
                                  cyclesBurnRate: CyclesBurnRateDefault;};
type MainerAgentCtrlbCanister = 
 service {
   addChallengeResponseToShareAgent: (ChallengeResponseSubmissionInput) ->
    (StatusCodeRecordResult);
   addChallengeToShareServiceQueue: (ChallengeQueueInput) ->
    (ChallengeQueueInputResult);
   addCycles: () -> (AddCyclesResult);
   addMainerShareAgentCanister: (OfficialMainerAgentCanister) ->
    (MainerAgentCanisterResult);
   addMainerShareAgentCanisterAdmin: (OfficialMainerAgentCanister) ->
    (MainerAgentCanisterResult);
   add_llm_canister: (CanisterIDRecord) -> (StatusCodeRecordResult);
   amiController: () -> (StatusCodeRecordResult) query;
   canAgentSettingsBeUpdated: () -> (StatusCodeRecordResult);
   checkAccessToLLMs: () -> (StatusCodeRecordResult);
   getChallengeQueueAdmin: () -> (ChallengeQueueInputsResult) query;
   getGameStateCanisterId: () -> (text) query;
   getIssueFlagsAdmin: () -> (IssueFlagsRetrievalResult) query;
   getLLMCanisterIds: () -> (CanisterAddressesResult) query;
   getMainerCanisterType: () -> (MainerAgentCanisterTypeResult) query;
   getMainerStatisticsAdmin: () -> (StatisticsRetrievalResult) query;
   getRecentSubmittedResponsesAdmin: () ->
    (ChallengeResponseSubmissionsResult) query;
   getRoundRobinCanister: () -> (CanisterIDRecordResult) query;
   getShareServiceCanisterId: () -> (text) query;
   getSubmittedResponsesAdmin: () ->
    (ChallengeResponseSubmissionsResult) query;
   health: () -> (StatusCodeRecordResult) query;
   ready: () -> (StatusCodeRecordResult);
   resetChallengeQueueAdmin: () -> (StatusCodeRecordResult);
   reset_llm_canisters: () -> (StatusCodeRecordResult);
   setGameStateCanisterId: (text) -> (StatusCodeRecordResult);
   setMainerCanisterType: (MainerAgentCanisterType) ->
    (StatusCodeRecordResult);
   setRoundRobinLLMs: (nat) -> (StatusCodeRecordResult);
   setShareServiceCanisterId: (text) -> (StatusCodeRecordResult);
   startTimerExecutionAdmin: () -> (AuthRecordResult);
   stopTimerExecutionAdmin: () -> (AuthRecordResult);
   timeToNextAgentSettingsUpdate: () -> (NatResult);
   triggerChallengeResponseAdmin: () -> (AuthRecordResult);
   updateAgentSettings: (MainerAgentSettingsInput) ->
    (StatusCodeRecordResult);
   whoami: () -> (principal) query;
 };
type MainerAgentCanisterTypeResult = 
 variant {
   Err: ApiError;
   Ok: MainerAgentCanisterType;
 };
type MainerAgentCanisterType = 
 variant {
   NA;
   Own;
   ShareAgent;
   ShareService;
 };
type MainerAgentCanisterResult = 
 variant {
   Err: ApiError;
   Ok: OfficialMainerAgentCanister;
 };
type LlmSetupStatus = 
 variant {
   CanisterCreated;
   CanisterCreationInProgress;
   CodeInstallInProgress;
   ConfigurationInProgress;
   ModelUploadProgress: nat8;
 };
type IssueFlagsRetrievalResult = 
 variant {
   Err: ApiError;
   Ok: IssueFlagsRecord;
 };
type IssueFlagsRecord = record {lowCycleBalance: bool;};
type CyclesBurnRateDefault = 
 variant {
   Custom: CyclesBurnRate;
   High;
   Low;
   Mid;
   VeryHigh;
 };
type CyclesBurnRate = 
 record {
   cycles: nat;
   timeInterval: TimeInterval;
 };
type ChallengeTopicStatus = 
 variant {
   Archived;
   Closed;
   Open;
   Other: text;
 };
type ChallengeStatus = 
 variant {
   Archived;
   Closed;
   Open;
   Other: text;
 };
type ChallengeResponseSubmissionsResult = 
 variant {
   Err: ApiError;
   Ok: vec ChallengeResponseSubmission;
 };
type ChallengeResponseSubmissionStatus = 
 variant {
   FailedSubmission;
   Judged;
   Judging;
   Other: text;
   Processed;
   Received;
   Submitted;
 };
type ChallengeResponseSubmissionInput = 
 record {
   challengeAnswer: text;
   challengeAnswerSeed: nat32;
   challengeClosedTimestamp: opt nat64;
   challengeCreatedBy: CanisterAddress;
   challengeCreationTimestamp: nat64;
   challengeId: text;
   challengeQuestion: text;
   challengeQuestionSeed: nat32;
   challengeQueuedBy: principal;
   challengeQueuedId: text;
   challengeQueuedTimestamp: nat64;
   challengeQueuedTo: principal;
   challengeStatus: ChallengeStatus;
   challengeTopic: text;
   challengeTopicCreationTimestamp: nat64;
   challengeTopicId: text;
   challengeTopicStatus: ChallengeTopicStatus;
   cyclesGenerateChallengeChctrlChllm: nat;
   cyclesGenerateChallengeGsChctrl: nat;
   cyclesGenerateResponseOwnctrlGs: nat;
   cyclesGenerateResponseOwnctrlOwnllmHIGH: nat;
   cyclesGenerateResponseOwnctrlOwnllmLOW: nat;
   cyclesGenerateResponseOwnctrlOwnllmMEDIUM: nat;
   cyclesGenerateResponseSactrlSsctrl: nat;
   cyclesGenerateResponseSsctrlGs: nat;
   cyclesGenerateResponseSsctrlSsllm: nat;
   cyclesSubmitResponse: nat;
   judgePromptId: text;
   mainerMaxContinueLoopCount: nat;
   mainerNumTokens: nat64;
   mainerPromptId: text;
   mainerTemp: float64;
   protocolOperationFeesCut: nat;
   submittedBy: principal;
 };
type ChallengeResponseSubmission = 
 record {
   challengeAnswer: text;
   challengeAnswerSeed: nat32;
   challengeClosedTimestamp: opt nat64;
   challengeCreatedBy: CanisterAddress;
   challengeCreationTimestamp: nat64;
   challengeId: text;
   challengeQuestion: text;
   challengeQuestionSeed: nat32;
   challengeQueuedBy: principal;
   challengeQueuedId: text;
   challengeQueuedTimestamp: nat64;
   challengeQueuedTo: principal;
   challengeStatus: ChallengeStatus;
   challengeTopic: text;
   challengeTopicCreationTimestamp: nat64;
   challengeTopicId: text;
   challengeTopicStatus: ChallengeTopicStatus;
   cyclesGenerateChallengeChctrlChllm: nat;
   cyclesGenerateChallengeGsChctrl: nat;
   cyclesGenerateResponseOwnctrlGs: nat;
   cyclesGenerateResponseOwnctrlOwnllmHIGH: nat;
   cyclesGenerateResponseOwnctrlOwnllmLOW: nat;
   cyclesGenerateResponseOwnctrlOwnllmMEDIUM: nat;
   cyclesGenerateResponseSactrlSsctrl: nat;
   cyclesGenerateResponseSsctrlGs: nat;
   cyclesGenerateResponseSsctrlSsllm: nat;
   cyclesGenerateScoreGsJuctrl: nat;
   cyclesGenerateScoreJuctrlJullm: nat;
   cyclesSubmitResponse: nat;
   judgePromptId: text;
   mainerMaxContinueLoopCount: nat;
   mainerNumTokens: nat64;
   mainerPromptId: text;
   mainerTemp: float64;
   protocolOperationFeesCut: nat;
   submissionId: text;
   submissionStatus: ChallengeResponseSubmissionStatus;
   submittedBy: principal;
   submittedTimestamp: nat64;
 };
type ChallengeQueueInputsResult = 
 variant {
   Err: ApiError;
   Ok: vec ChallengeQueueInput;
 };
type ChallengeQueueInputResult = 
 variant {
   Err: ApiError;
   Ok: ChallengeQueueInput;
 };
type ChallengeQueueInput = 
 record {
   challengeClosedTimestamp: opt nat64;
   challengeCreatedBy: CanisterAddress;
   challengeCreationTimestamp: nat64;
   challengeId: text;
   challengeQuestion: text;
   challengeQuestionSeed: nat32;
   challengeQueuedBy: principal;
   challengeQueuedId: text;
   challengeQueuedTimestamp: nat64;
   challengeQueuedTo: principal;
   challengeStatus: ChallengeStatus;
   challengeTopic: text;
   challengeTopicCreationTimestamp: nat64;
   challengeTopicId: text;
   challengeTopicStatus: ChallengeTopicStatus;
   cyclesGenerateChallengeChctrlChllm: nat;
   cyclesGenerateChallengeGsChctrl: nat;
   cyclesGenerateResponseOwnctrlGs: nat;
   cyclesGenerateResponseOwnctrlOwnllmHIGH: nat;
   cyclesGenerateResponseOwnctrlOwnllmLOW: nat;
   cyclesGenerateResponseOwnctrlOwnllmMEDIUM: nat;
   cyclesGenerateResponseSactrlSsctrl: nat;
   cyclesGenerateResponseSsctrlGs: nat;
   cyclesGenerateResponseSsctrlSsllm: nat;
   cyclesSubmitResponse: nat;
   judgePromptId: text;
   mainerMaxContinueLoopCount: nat;
   mainerNumTokens: nat64;
   mainerPromptId: text;
   mainerTemp: float64;
   protocolOperationFeesCut: nat;
 };
type CanisterStatus = 
 variant {
   ControllerCreated;
   ControllerCreationInProgress;
   LlmSetupFinished;
   LlmSetupInProgress: LlmSetupStatus;
   Other: text;
   Paid;
   Paused;
   Running;
   Unlocked;
 };
type CanisterIDRecordResult = 
 variant {
   Err: ApiError;
   Ok: CanisterIDRecord;
 };
type CanisterIDRecord = record {canister_id: text;};
type CanisterAddressesResult = 
 variant {
   Err: ApiError;
   Ok: vec CanisterAddress;
 };
type CanisterAddress = text;
type AuthRecordResult = 
 variant {
   Err: ApiError;
   Ok: AuthRecord;
 };
type AuthRecord = record {auth: text;};
type ApiError = 
 variant {
   FailedOperation;
   InsuffientCycles: nat;
   InvalidId;
   Other: text;
   StatusCode: StatusCode;
   Unauthorized;
   ZeroAddress;
 };
type AddCyclesResult = 
 variant {
   Err: ApiError;
   Ok: AddCyclesRecord;
 };
type AddCyclesRecord = 
 record {
   added: bool;
   amount: nat;
 };
service : () -> MainerAgentCtrlbCanister
