type WhitelistMainerCreationInput = 
 record {
   address: CanisterAddress;
   canisterType: ProtocolCanisterType;
   createdBy: principal;
   creationTimestamp: nat64;
   mainerConfig: MainerConfigurationInput;
   ownedBy: principal;
   owner: opt principal;
   paymentTransactionBlockId: nat64;
   status: CanisterStatus;
   subnet: text;
 };
type Value__1 = 
 variant {
   Array: vec Value__1;
   Blob: blob;
   Int: int;
   Map: vec record {
              text;
              Value__1;
            };
   Nat: nat;
   Text: text;
 };
type Value = 
 variant {
   Array: vec Value__1;
   Blob: blob;
   Int: int;
   Map: vec record {
              text;
              Value__1;
            };
   Nat: nat;
   Text: text;
 };
type UploadMainerPromptCacheBytesChunkInput = 
 record {
   bytesChunk: blob;
   chunkID: nat;
   mainerPromptId: text;
 };
type UploadJudgePromptCacheBytesChunkInput = 
 record {
   bytesChunk: blob;
   chunkID: nat;
   judgePromptId: text;
 };
type UpdateWasmHashInput = 
 record {
   textNote: text;
   wasmHash: blob;
 };
type TransferFromResult = 
 variant {
   Err: TransferFromError;
   Ok: nat;
 };
type TransferFromError = 
 variant {
   CreatedInFuture: record {ledger_time: nat64;};
   Duplicate: record {duplicate_of: nat;};
   GenericBatchError: record {
                        error_code: nat;
                        message: text;
                      };
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   InvalidRecipient;
   NonExistingTokenId;
   TooOld;
   Unauthorized;
 };
type TransferFromArg = 
 record {
   created_at_time: opt nat64;
   from: Account__1;
   memo: opt blob;
   spender_subaccount: opt blob;
   to: Account__1;
   token_id: nat;
 };
type TimeInterval = variant {Daily;};
type TextResult = 
 variant {
   Err: ApiError;
   Ok: text;
 };
type SupportedStandards = 
 vec record {
       name: text;
       url: text;
     };
type SubnetIdsResult = 
 variant {
   Err: ApiError;
   Ok: SubnetIds;
 };
type SubnetIds = 
 record {
   subnetShareAgentCtrl: text;
   subnetShareServiceCtrl: text;
   subnetShareServiceLlm: text;
 };
type SubmissionRetrievalInput = 
 record {
   challengeId: text;
   submissionId: text;
 };
type Subaccount = blob;
type StatusCodeRecordResult = 
 variant {
   Err: ApiError;
   Ok: StatusCodeRecord;
 };
type StatusCodeRecord = record {status_code: StatusCode;};
type StatusCode = nat16;
type StartUploadMainerPromptCacheRecordResult = 
 variant {
   Err: ApiError;
   Ok: StartUploadMainerPromptCacheRecord;
 };
type StartUploadMainerPromptCacheRecord = record {mainerPromptId: text;};
type StartUploadJudgePromptCacheRecordResult = 
 variant {
   Err: ApiError;
   Ok: StartUploadJudgePromptCacheRecord;
 };
type StartUploadJudgePromptCacheRecord = record {judgePromptId: text;};
type SetUpMainerLlmCanisterResult = 
 variant {
   Err: ApiError;
   Ok:
    record {
      controllerCanisterEntry: OfficialMainerAgentCanister;
      llmCanisterId: text;
    };
 };
type SetCyclesBurnRateInput = 
 record {
   cyclesBurnRate: CyclesBurnRate;
   cyclesBurnRateDefault: CyclesBurnRateDefault;
 };
type SelectableMainerLLMs = variant {Qwen2_5_500M;};
type ScoredResponseReturn = record {success: bool;};
type ScoredResponseRetrievalResult = 
 variant {
   Err: ApiError;
   Ok: ScoredResponse;
 };
type ScoredResponseResult = 
 variant {
   Err: ApiError;
   Ok: ScoredResponseReturn;
 };
type ScoredResponseInput = 
 record {
   challengeAnswer: text;
   challengeAnswerSeed: nat32;
   challengeClosedTimestamp: opt nat64;
   challengeCreatedBy: CanisterAddress;
   challengeCreationTimestamp: nat64;
   challengeId: text;
   challengeQuestion: text;
   challengeQuestionSeed: nat32;
   challengeQueuedBy: principal;
   challengeQueuedId: text;
   challengeQueuedTimestamp: nat64;
   challengeQueuedTo: principal;
   challengeStatus: ChallengeStatus;
   challengeTopic: text;
   challengeTopicCreationTimestamp: nat64;
   challengeTopicId: text;
   challengeTopicStatus: ChallengeTopicStatus;
   cyclesGenerateChallengeChctrlChllm: nat;
   cyclesGenerateChallengeGsChctrl: nat;
   cyclesGenerateResponseOwnctrlGs: nat;
   cyclesGenerateResponseOwnctrlOwnllmHIGH: nat;
   cyclesGenerateResponseOwnctrlOwnllmLOW: nat;
   cyclesGenerateResponseOwnctrlOwnllmMEDIUM: nat;
   cyclesGenerateResponseSactrlSsctrl: nat;
   cyclesGenerateResponseSsctrlGs: nat;
   cyclesGenerateResponseSsctrlSsllm: nat;
   cyclesGenerateScoreGsJuctrl: nat;
   cyclesGenerateScoreJuctrlJullm: nat;
   cyclesSubmitResponse: nat;
   judgePromptId: text;
   judgedBy: principal;
   mainerMaxContinueLoopCount: nat;
   mainerNumTokens: nat64;
   mainerPromptId: text;
   mainerTemp: float64;
   protocolOperationFeesCut: nat;
   score: nat;
   scoreSeed: nat32;
   submissionId: text;
   submissionStatus: ChallengeResponseSubmissionStatus;
   submittedBy: principal;
   submittedTimestamp: nat64;
 };
type ScoredResponse = 
 record {
   challengeAnswer: text;
   challengeAnswerSeed: nat32;
   challengeClosedTimestamp: opt nat64;
   challengeCreatedBy: CanisterAddress;
   challengeCreationTimestamp: nat64;
   challengeId: text;
   challengeQuestion: text;
   challengeQuestionSeed: nat32;
   challengeQueuedBy: principal;
   challengeQueuedId: text;
   challengeQueuedTimestamp: nat64;
   challengeQueuedTo: principal;
   challengeStatus: ChallengeStatus;
   challengeTopic: text;
   challengeTopicCreationTimestamp: nat64;
   challengeTopicId: text;
   challengeTopicStatus: ChallengeTopicStatus;
   cyclesGenerateChallengeChctrlChllm: nat;
   cyclesGenerateChallengeGsChctrl: nat;
   cyclesGenerateResponseOwnctrlGs: nat;
   cyclesGenerateResponseOwnctrlOwnllmHIGH: nat;
   cyclesGenerateResponseOwnctrlOwnllmLOW: nat;
   cyclesGenerateResponseOwnctrlOwnllmMEDIUM: nat;
   cyclesGenerateResponseSactrlSsctrl: nat;
   cyclesGenerateResponseSsctrlGs: nat;
   cyclesGenerateResponseSsctrlSsllm: nat;
   cyclesGenerateScoreGsJuctrl: nat;
   cyclesGenerateScoreJuctrlJullm: nat;
   cyclesSubmitResponse: nat;
   judgePromptId: text;
   judgedBy: principal;
   judgedTimestamp: nat64;
   mainerMaxContinueLoopCount: nat;
   mainerNumTokens: nat64;
   mainerPromptId: text;
   mainerTemp: float64;
   protocolOperationFeesCut: nat;
   score: nat;
   scoreSeed: nat32;
   submissionId: text;
   submissionStatus: ChallengeResponseSubmissionStatus;
   submittedBy: principal;
   submittedTimestamp: nat64;
 };
type ScoredChallengesResult = 
 variant {
   Err: ApiError;
   Ok: vec record {
             text;
             List;
           };
 };
type RewardType = 
 variant {
   Coupon: text;
   Cycles;
   ICP;
   MainerToken;
   Other: text;
 };
type RewardPerChallengeResult = 
 variant {
   Err: ApiError;
   Ok: RewardPerChallenge;
 };
type RewardPerChallenge = 
 record {
   amountForAllParticipants: nat;
   rewardType: RewardType;
   secondPlaceAmount: nat;
   thirdPlaceAmount: nat;
   totalAmount: nat;
   winnerAmount: nat;
 };
type RevokeTokenApprovalResult = 
 variant {
   Err: RevokeTokenApprovalError;
   Ok: nat;
 };
type RevokeTokenApprovalError = 
 variant {
   ApprovalDoesNotExist;
   CreatedInFuture: record {ledger_time: nat64;};
   Duplicate: record {duplicate_of: nat;};
   GenericBatchError: record {
                        error_code: nat;
                        message: text;
                      };
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   NonExistingTokenId;
   TooOld;
   Unauthorized;
 };
type RevokeTokenApprovalArg = 
 record {
   created_at_time: opt nat64;
   from_subaccount: opt blob;
   memo: opt blob;
   spender: opt Account__1;
   token_id: nat;
 };
type RedeemedTransactionBlocksResult = 
 variant {
   Err: ApiError;
   Ok: vec RedeemedTransactionBlock;
 };
type RedeemedTransactionBlockResult = 
 variant {
   Err: ApiError;
   Ok: RedeemedTransactionBlock;
 };
type RedeemedTransactionBlock = 
 record {
   amount: nat;
   creationTimestamp: nat64;
   paymentTransactionBlockId: nat64;
   redeemedBy: principal;
   redeemedFor: RedeemedForOptions;
 };
type RedeemedForOptions = 
 variant {
   MainerCreation: MainerAgentCanisterType;
   MainerTopUp: CanisterAddress;
 };
type ProtocolCanisterType = 
 variant {
   Challenger;
   Judge;
   MainerAgent: MainerAgentCanisterType;
   MainerCreator;
   MainerLlm;
   Verifier;
 };
type ProtocolActivityResult = 
 variant {
   Err: ApiError;
   Ok: ProtocolActivityRecord;
 };
type ProtocolActivityRecord = 
 record {
   challenges: vec Challenge;
   winners: vec ChallengeWinnerDeclaration;
 };
type PriceResult = 
 variant {
   Err: ApiError;
   Ok: PriceRecord;
 };
type PriceRecord = record {price: nat64;};
type PaymentTransactionBlockId = record {paymentTransactionBlockId: nat64;};
type OfficialProtocolCanistersResult = 
 variant {
   Err: ApiError;
   Ok: vec OfficialProtocolCanister;
 };
type OfficialProtocolCanister = 
 record {
   address: CanisterAddress;
   canisterType: ProtocolCanisterType;
   createdBy: principal;
   creationTimestamp: nat64;
   ownedBy: principal;
   status: CanisterStatus;
   subnet: text;
 };
type OfficialMainerAgentCanister = 
 record {
   address: CanisterAddress;
   canisterType: ProtocolCanisterType;
   createdBy: principal;
   creationTimestamp: nat64;
   mainerConfig: MainerConfigurationInput;
   ownedBy: principal;
   status: CanisterStatus;
   subnet: text;
 };
type NewChallengeInput = 
 record {
   challengeQuestion: text;
   challengeQuestionSeed: nat32;
   challengeTopic: text;
   challengeTopicCreationTimestamp: nat64;
   challengeTopicId: text;
   challengeTopicStatus: ChallengeTopicStatus;
   cyclesGenerateChallengeChctrlChllm: nat;
   cyclesGenerateChallengeGsChctrl: nat;
   judgePromptId: text;
   mainerMaxContinueLoopCount: nat;
   mainerNumTokens: nat64;
   mainerPromptId: text;
   mainerTemp: float64;
 };
type NatResult = 
 variant {
   Err: ApiError;
   Ok: nat;
 };
type MarketplaceTransactionHistoryResult = 
 variant {
   Err: ApiError;
   Ok: MarketplaceTransactionHistory;
 };
type MarketplaceTransactionHistory = 
 record {
   purchases: vec MarketplaceSale;
   sales: vec MarketplaceSale;
 };
type MarketplaceStats = 
 record {
   totalSales: nat;
   totalVolumeE8S: nat;
   uniqueBuyers: nat;
   uniqueSellers: nat;
 };
type MarketplaceSale = 
 record {
   buyer: principal;
   mainerAddress: text;
   priceE8S: nat;
   saleTimestamp: nat64;
   seller: principal;
 };
type MainerctrlUpgradeInput = record {canisterAddress: CanisterAddress;};
type MainerctrlReinstallInput = record {canisterAddress: CanisterAddress;};
type MainerPromptInfoResult = 
 variant {
   Err: ApiError;
   Ok: MainerPromptInfo;
 };
type MainerPromptInfo = 
 record {
   promptCacheFilename: text;
   promptCacheNumberOfChunks: nat;
   promptCacheSha256: text;
   promptText: text;
 };
type MainerMarketplaceReservationResult = 
 variant {
   Err: ApiError;
   Ok: MainerMarketplaceListing;
 };
type MainerMarketplaceReservationInput = record {address: CanisterAddress;};
type MainerMarketplaceListingsResult = 
 variant {
   Err: ApiError;
   Ok: vec MainerMarketplaceListing;
 };
type MainerMarketplaceListing = 
 record {
   address: CanisterAddress;
   listedBy: principal;
   listedTimestamp: nat64;
   mainerType: MainerAgentCanisterType;
   priceE8S: nat;
   reservedBy: opt principal;
 };
type MainerLimitInput = 
 record {
   mainerType: MainerAgentCanisterType;
   newLimit: nat;
 };
type MainerCreationInput = 
 record {
   mainerConfig: MainerConfigurationInput;
   owner: opt principal;
   paymentTransactionBlockId: nat64;
 };
type MainerConfigurationInput = 
 record {
   cyclesForMainer: nat;
   mainerAgentCanisterType: MainerAgentCanisterType;
   selectedLLM: opt SelectableMainerLLMs;
   subnetCtrl: text;
   subnetLlm: text;
 };
type MainerAuctionTimerInfoResult = 
 variant {
   Err: ApiError;
   Ok: MainerAuctionTimerInfoRecord;
 };
type MainerAuctionTimerInfoRecord = 
 record {
   active: bool;
   intervalSeconds: nat;
   lastUpdateNs: nat;
 };
type MainerAgentTopUpInput = 
 record {
   mainerAgent: OfficialMainerAgentCanister;
   paymentTransactionBlockId: nat64;
 };
type MainerAgentCanistersResult = 
 variant {
   Err: ApiError;
   Ok: vec OfficialMainerAgentCanister;
 };
type MainerAgentCanisterType = 
 variant {
   NA;
   Own;
   ShareAgent;
   ShareService;
 };
type MainerAgentCanisterResult = 
 variant {
   Err: ApiError;
   Ok: OfficialMainerAgentCanister;
 };
type LlmSetupStatus = 
 variant {
   CanisterCreated;
   CanisterCreationInProgress;
   CodeInstallInProgress;
   ConfigurationInProgress;
   ModelUploadProgress: nat8;
 };
type List_1 = 
 opt record {
       ChallengeParticipantEntry;
       List_1;
     };
type List = 
 opt record {
       ScoredResponse;
       List;
     };
type JudgePromptInfoResult = 
 variant {
   Err: ApiError;
   Ok: JudgePromptInfo;
 };
type JudgePromptInfo = 
 record {
   promptCacheFilename: text;
   promptCacheNumberOfChunks: nat;
   promptCacheSha256: text;
   promptText: text;
 };
type GameStateTresholdsResult = 
 variant {
   Err: ApiError;
   Ok: GameStateTresholds;
 };
type GameStateTresholds = 
 record {
   thresholdArchiveClosedChallenges: nat;
   thresholdMaxOpenChallenges: nat;
   thresholdMaxOpenSubmissions: nat;
   thresholdScoredResponsesPerChallenge: nat;
 };
type GameStateCanister = 
 service {
   addChallenge: (NewChallengeInput) -> (ChallengeAdditionResult);
   addChallengeTopic: (ChallengeTopicInput) -> (ChallengeTopicResult);
   addCycles: () -> (AddCyclesResult);
   addLlmCanisterToMainer: (OfficialMainerAgentCanister) ->
    (SetUpMainerLlmCanisterResult);
   addMainerAgentCanister: (OfficialMainerAgentCanister) ->
    (MainerAgentCanisterResult);
   addMainerAgentCanisterAdmin: (OfficialMainerAgentCanister) ->
    (MainerAgentCanisterResult);
   addOfficialCanister: (CanisterInput) -> (StatusCodeRecordResult);
   addScoredResponse: (ScoredResponseInput) -> (ScoredResponseResult);
   archiveSubmissionsAdmin: () -> (NatResult);
   backupMainersAdmin: () -> (NatResult);
   cancelMarketplaceReservation: (MainerMarketplaceReservationInput) ->
    (StatusCodeRecordResult);
   checkUserMainerMappingConsistencyAdmin: () -> (AuthRecordResult) query;
   cleanOpenSubmissionsQueueAdmin: () -> (NatResult);
   cleanSubmissionsAdmin: () -> (AuthRecordResult);
   cleanUnlockedMainerStoragesAdmin: () -> (AuthRecordResult);
   clearMarketplaceReservationsAdmin: () -> (AuthRecordResult);
   completeMainerSetupForUserAdmin: (OfficialMainerAgentCanister) ->
    (MainerAgentCanisterResult);
   confirmUserMarketplaceMainerReservation:
    (MainerMarketplaceReservationInput) ->
    (MainerMarketplaceReservationResult) query;
   createUserMainerAgent: (MainerCreationInput) ->
    (MainerAgentCanisterResult);
   deriveNewMainerAgentCanisterWasmHashAdmin: (DeriveWasmHashInput) ->
    (CanisterWasmHashRecordResult);
   disburseIcpToTreasuryAdmin: () -> (AuthRecordResult);
   downloadJudgePromptCacheBytesChunk:
    (DownloadJudgePromptCacheBytesChunkInput) ->
    (DownloadJudgePromptCacheBytesChunkRecordResult) query;
   downloadMainerPromptCacheBytesChunk:
    (DownloadMainerPromptCacheBytesChunkInput) ->
    (DownloadMainerPromptCacheBytesChunkRecordResult) query;
   finishUploadJudgePromptCache: (FinishUploadJudgePromptCacheInput) ->
    (StatusCodeRecordResult);
   finishUploadMainerPromptCache: (FinishUploadMainerPromptCacheInput) ->
    (StatusCodeRecordResult);
   getArchivedChallengesAdmin: () -> (ChallengesResult) query;
   getAvailableMainers: () -> (NatResult) query;
   getBufferMainerCreation: () -> (NatResult) query;
   getCanisterPrincipal: () -> (text) query;
   getClosedChallengesAdmin: () -> (ChallengesResult) query;
   getCurrentChallenges: () -> (ChallengesResult) query;
   getCurrentChallengesAdmin: () -> (ChallengesResult) query;
   getCyclesBalanceThresholdFunnaiTopups: () -> (NatResult) query;
   getCyclesBurnRate: (CyclesBurnRateDefault) -> (CyclesBurnRateResult);
   getCyclesFlowAdmin: () -> (CyclesFlowResult);
   getCyclesTransactionsAdmin: () -> (CyclesTransactionsResult) query;
   getDisburseFundsToTreasuryFlag: () -> (FlagResult) query;
   getFunnaiCyclesPrice: () -> (NatResult) query;
   getFunnaiCyclesPriceAdmin: () -> (NatResult) query;
   getGameStateThresholdsAdmin: () -> (GameStateTresholdsResult) query;
   getIsMainerAuctionActive: () -> (FlagResult) query;
   getIsMigratingChallengesFlagAdmin: () -> (FlagResult) query;
   getIsWhitelistPhaseActive: () -> (FlagResult) query;
   getJudgePromptInfo: (text) -> (JudgePromptInfoResult) query;
   getLimitForCreatingMainerAdmin: (CheckMainerLimit) -> (NatResult) query;
   getMainerAgentCanisterInfo: (CanisterRetrieveInput) ->
    (MainerAgentCanisterResult) query;
   getMainerAgentCanistersAdmin: () -> (MainerAgentCanistersResult) query;
   getMainerAgentCanistersForUser: () -> (MainerAgentCanistersResult) query;
   getMainerAgentCanistersForUserAdmin: (text) ->
    (MainerAgentCanistersResult) query;
   getMainerAuctionTimerInfo: () -> (MainerAuctionTimerInfoResult) query;
   getMainerCyclesUsedPerResponse: () -> (NatResult);
   getMainerPromptInfo: (text) -> (MainerPromptInfoResult) query;
   getMarketplaceMainerListings: () ->
    (MainerMarketplaceListingsResult) query;
   getMarketplaceSalesStats: () -> (MarketplaceStats) query;
   getMaxFunnaiTopupCyclesAmount: () -> (NatResult) query;
   getMaxFunnaiTopupCyclesAmountAdmin: () -> (NatResult) query;
   getMinimumIcpBalance: () -> (NatResult) query;
   getNextMainerAuctionPriceDropAtNs: () -> (NatResult) query;
   getNextSubmissionToJudge: () ->
    (ChallengeResponseSubmissionWithQueueStatusResult);
   getNumArchivedChallengesAdmin: () -> (NatResult) query;
   getNumArchivedSubmissionsAdmin: () -> (NatResult) query;
   getNumClosedChallengesAdmin: () -> (NatResult) query;
   getNumCurrentChallengesAdmin: () -> (NatResult) query;
   getNumMainerAgentCanistersForUserAdmin: (text) -> (NatResult) query;
   getNumOpenSubmissionsAdmin: () -> (NatResult) query;
   getNumOpenSubmissionsForOpenChallengesAdmin: () -> (NatResult) query;
   getNumScoredChallengesAdmin: () -> (NatResult) query;
   getNumSubmissionsAdmin: () -> (NatResult) query;
   getNumSubmissionsToMigrateAdmin: () -> (NatResult) query;
   getNumberMainerAgentsAdmin: (CheckMainerLimit) -> (NatResult) query;
   getOfficialCanistersAdmin: () -> (vec OfficialProtocolCanister) query;
   getOfficialChallengerCanisters: () -> (AuthRecordResult);
   getOpenSubmissionsAdmin: () -> (ChallengeResponseSubmissionsResult) query;
   getOpenSubmissionsForOpenChallengesAdmin: () ->
    (ChallengeResponseSubmissionsResult) query;
   getOpenSubmissionsQueueSizeAdmin: () -> (NatResult) query;
   getPauseProtocolFlag: () -> (FlagResult) query;
   getPauseWhitelistMainerCreationFlag: () -> (FlagResult) query;
   getPriceForOwnMainer: () -> (PriceResult) query;
   getPriceForShareAgent: () -> (PriceResult) query;
   getProtocolCyclesBalanceBuffer: () -> (NatResult) query;
   getProtocolTotalCyclesBurnt: () -> (CyclesBurntResult) query;
   getRandomOpenChallenge: () -> (ChallengeResult);
   getRandomOpenChallengeAdmin: () -> (ChallengeResult);
   getRandomOpenChallengeTopic: () -> (ChallengeTopicResult);
   getRandomOpenChallengeTopicAdmin: () -> (ChallengeTopicResult);
   getRecentChallengeWinners: () -> (ChallengeWinnersResult) query;
   getRecentProtocolActivity: () -> (ProtocolActivityResult) query;
   getRedeemedFunnaiTransactionBlockAdmin: (PaymentTransactionBlockId) ->
    (RedeemedTransactionBlockResult);
   getRedeemedFunnaiTransactionBlocksAdmin: () ->
    (RedeemedTransactionBlocksResult);
   getRedeemedTransactionBlockAdmin: (PaymentTransactionBlockId) ->
    (RedeemedTransactionBlockResult);
   getRedeemedTransactionBlocksAdmin: () -> (RedeemedTransactionBlocksResult);
   getRewardPerChallengeAdmin: () -> (RewardPerChallengeResult);
   getRoundRobinChallengeIndexAdmin: () -> (NatResult) query;
   getRoundRobinTopicIndexAdmin: () -> (NatResult) query;
   getScoreForSubmission: (SubmissionRetrievalInput) ->
    (ScoredResponseRetrievalResult) query;
   getScoredChallengesAdmin: () -> (ScoredChallengesResult) query;
   getSharedServiceCanistersAdmin: () -> (OfficialProtocolCanistersResult);
   getSubmissionsAdmin: () -> (ChallengeResponseSubmissionsResult) query;
   getSubnetsAdmin: () -> (SubnetIdsResult) query;
   getTreasuryCanisterId: () -> (text) query;
   getUserMarketplaceMainerListings: () ->
    (MainerMarketplaceListingsResult) query;
   getUserMarketplaceReservation: () -> (opt MainerMarketplaceListing) query;
   getUserMarketplaceTransactionHistory: () ->
    (MarketplaceTransactionHistoryResult) query;
   getWhitelistPriceForOwnMainer: () -> (PriceResult) query;
   getWhitelistPriceForShareAgent: () -> (PriceResult) query;
   health: () -> (StatusCodeRecordResult) query;
   icrc10_supported_standards: () -> (SupportedStandards) query;
   icrc37_approve_tokens: (vec ApproveTokenArg) ->
    (vec opt ApproveTokenResult);
   icrc37_revoke_token_approvals: (vec RevokeTokenApprovalArg) ->
    (vec opt RevokeTokenApprovalResult);
   icrc37_transfer_from: (vec TransferFromArg) ->
    (vec opt TransferFromResult);
   icrc7_balance_of: (vec Account) -> (vec nat) query;
   icrc7_collection_metadata: () -> (vec record {
                                           text;
                                           Value;
                                         }) query;
   icrc7_description: () -> (opt text) query;
   icrc7_logo: () -> (opt text) query;
   icrc7_name: () -> (text) query;
   icrc7_supply_cap: () -> (opt nat) query;
   icrc7_symbol: () -> (text) query;
   icrc7_token_metadata: (vec nat) ->
    (vec opt vec record {
                   text;
                   Value;
                 }) query;
   icrc7_tokens: (opt nat, opt nat) -> (vec nat) query;
   icrc7_total_supply: () -> (nat) query;
   initializeOpenSubmissionsQueueAdmin: () -> (AuthRecordResult);
   isMainerReservedOnMarketplaceAdmin: (text) -> (bool) query;
   migrateArchivedChallengesAdmin: () -> (NatResult);
   migrateScoredResponsesForChallengeAdmin: (text) -> (AuthRecordResult);
   migrateSubmissionsAdmin: () -> (AuthRecordResult);
   migrateWinnerDeclarationsAdmin: (vec text) -> (AuthRecordResult);
   reinstallMainerControllerAdmin: (MainerctrlReinstallInput) ->
    (MainerAgentCanisterResult);
   removeRedeemedFunnaiTransactionBlockAdmin: (PaymentTransactionBlockId) ->
    (TextResult);
   removeRedeemedTransactionBlockAdmin: (PaymentTransactionBlockId) ->
    (TextResult);
   removeSharedServiceCanisterAdmin: (record {canisterId: text;}) ->
    (StatusCodeRecordResult);
   reserveMarketplaceListedMainer: (MainerMarketplaceReservationInput) ->
    (MainerMarketplaceReservationResult);
   resetCurrentChallengesAdmin: () -> (StatusCodeRecordResult);
   resetCyclesFlowAdmin: () -> (StatusCodeRecordResult);
   resetIsMigratingChallengesFlagAdmin: () -> (AuthRecordResult);
   resetRoundRobinChallengeIndexAdmin: () -> (StatusCodeRecordResult);
   resetRoundRobinTopicIndexAdmin: () -> (StatusCodeRecordResult);
   setApiCanisterId: (text) -> (AuthRecordResult);
   setArchiveCanisterId: (text) -> (AuthRecordResult);
   setAuctionIntervalSecondsAdmin: (nat) -> (AuthRecordResult);
   setAuctionPricesAdmin: (vec nat64) -> (AuthRecordResult);
   setBufferMainerCreation: (nat) -> (AuthRecordResult);
   setCyclesBalanceThresholdFunnaiTopups: (nat) -> (AuthRecordResult);
   setCyclesBurnRateAdmin: (SetCyclesBurnRateInput) ->
    (StatusCodeRecordResult);
   setCyclesFlowAdmin: (CyclesFlowSettings) -> (StatusCodeRecordResult);
   setFunnaiCyclesPrice: (nat) -> (AuthRecordResult);
   setGameStateThresholdsAdmin: (GameStateTresholds) ->
    (StatusCodeRecordResult);
   setIcpForOwnMainerAdmin: (nat64) -> (StatusCodeRecordResult);
   setIcpForShareAgentAdmin: (nat64) -> (StatusCodeRecordResult);
   setIcpForWhitelistOwnMainerAdmin: (nat64) -> (StatusCodeRecordResult);
   setIcpForWhitelistShareAgentAdmin: (nat64) -> (StatusCodeRecordResult);
   setInitialChallengeTopics: () -> (StatusCodeRecordResult);
   setLimitForCreatingMainerAdmin: (MainerLimitInput) -> (AuthRecordResult);
   setMaxFunnaiTopupCyclesAmount: (nat) -> (AuthRecordResult);
   setMinimumIcpBalance: (nat) -> (AuthRecordResult);
   setNumSubmissionsToMigrateAdmin: (nat) -> (NatResult);
   setOfficialMainerAgentCanisterWasmHashAdmin: (UpdateWasmHashInput) ->
    (CanisterWasmHashRecordResult);
   setProtocolCyclesBalanceBuffer: (nat) -> (AuthRecordResult);
   setRewardPerChallengeAdmin: (nat) -> (RewardPerChallengeResult);
   setSubnetsAdmin: (SubnetIds) -> (StatusCodeRecordResult);
   setTokenLedgerCanisterId: (text) -> (AuthRecordResult);
   setTreasuryCanisterId: (text) -> (AuthRecordResult);
   setUpMainerLlmCanister: (OfficialMainerAgentCanister) ->
    (SetUpMainerLlmCanisterResult);
   setupAuctionAdmin: (vec nat64, nat) -> (AuthRecordResult);
   shouldCreatingMainersBeStopped: (CheckMainerLimit) -> (FlagResult) query;
   spinUpMainerControllerCanister: (OfficialMainerAgentCanister) ->
    (MainerAgentCanisterResult);
   spinUpMainerControllerCanisterForUserAdmin:
    (OfficialMainerAgentCanister) -> (MainerAgentCanisterResult);
   startAuctionAdmin: () -> (AuthRecordResult);
   startUploadJudgePromptCache: () ->
    (StartUploadJudgePromptCacheRecordResult);
   startUploadMainerPromptCache: () ->
    (StartUploadMainerPromptCacheRecordResult);
   stopAuctionAdmin: () -> (AuthRecordResult);
   submitChallengeResponse: (ChallengeResponseSubmissionInput) ->
    (ChallengeResponseSubmissionMetadataResult);
   testDisbursementToTreasuryAdmin: () -> (AuthRecordResult);
   testMainerCodeIntegrityAdmin: () -> (AuthRecordResult);
   testTokenMintingAdmin: () -> (AuthRecordResult);
   toggleDisburseFundsToTreasuryFlagAdmin: () -> (AuthRecordResult);
   togglePauseProtocolFlagAdmin: () -> (AuthRecordResult);
   togglePauseWhitelistMainerCreationFlagAdmin: () -> (AuthRecordResult);
   toggleWhitelistPhaseActiveFlagAdmin: () -> (AuthRecordResult);
   topUpCyclesForMainerAgent: (MainerAgentTopUpInput) ->
    (MainerAgentCanisterResult);
   topUpCyclesForMainerAgentWithFunnai: (MainerAgentTopUpInput) ->
    (MainerAgentCanisterResult);
   unlockUserMainerAgent: (MainerCreationInput) ->
    (MainerAgentCanisterResult);
   upgradeMainerControllerAdmin: (MainerctrlUpgradeInput) ->
    (MainerAgentCanisterResult);
   uploadJudgePromptCacheBytesChunk:
    (UploadJudgePromptCacheBytesChunkInput) -> (StatusCodeRecordResult);
   uploadMainerPromptCacheBytesChunk:
    (UploadMainerPromptCacheBytesChunkInput) -> (StatusCodeRecordResult);
   whitelistCreateUserMainerAgent: (WhitelistMainerCreationInput) ->
    (MainerAgentCanisterResult);
 };
type FlagResult = 
 variant {
   Err: ApiError;
   Ok: FlagRecord;
 };
type FlagRecord = record {flag: bool;};
type FinishUploadMainerPromptCacheInput = 
 record {
   mainerPromptId: text;
   promptCacheFilename: text;
   promptCacheSha256: text;
   promptText: text;
 };
type FinishUploadJudgePromptCacheInput = 
 record {
   judgePromptId: text;
   promptCacheFilename: text;
   promptCacheSha256: text;
   promptText: text;
 };
type DownloadMainerPromptCacheBytesChunkRecordResult = 
 variant {
   Err: ApiError;
   Ok: DownloadMainerPromptCacheBytesChunkRecord;
 };
type DownloadMainerPromptCacheBytesChunkRecord = 
 record {
   bytesChunk: blob;
   chunkID: nat;
   mainerPromptId: text;
 };
type DownloadMainerPromptCacheBytesChunkInput = 
 record {
   chunkID: nat;
   mainerPromptId: text;
 };
type DownloadJudgePromptCacheBytesChunkRecordResult = 
 variant {
   Err: ApiError;
   Ok: DownloadJudgePromptCacheBytesChunkRecord;
 };
type DownloadJudgePromptCacheBytesChunkRecord = 
 record {
   bytesChunk: blob;
   chunkID: nat;
   judgePromptId: text;
 };
type DownloadJudgePromptCacheBytesChunkInput = 
 record {
   chunkID: nat;
   judgePromptId: text;
 };
type DeriveWasmHashInput = 
 record {
   address: CanisterAddress;
   textNote: text;
 };
type CyclesTransactionsResult = 
 variant {
   Err: ApiError;
   Ok: vec CyclesTransaction;
 };
type CyclesTransaction = 
 record {
   amountAdded: nat;
   creationTimestamp: nat64;
   newOfficialCycleBalance: nat;
   previousCyclesBalance: nat;
   sentBy: principal;
   succeeded: bool;
 };
type CyclesFlowSettings = 
 record {
   costCreateMainerCtrl: opt nat;
   costCreateMainerLlm: opt nat;
   costCreateMcMainerCtrl: opt nat;
   costCreateMcMainerLlm: opt nat;
   costGenerateChallengeChctrl: opt nat;
   costGenerateChallengeChllm: opt nat;
   costGenerateChallengeGs: opt nat;
   costGenerateResponseOwnGs: opt nat;
   costGenerateResponseOwnctrl: opt nat;
   costGenerateResponseOwnllm: opt nat;
   costGenerateResponseSactrl: opt nat;
   costGenerateResponseShareGs: opt nat;
   costGenerateResponseSsctrl: opt nat;
   costGenerateResponseSsllm: opt nat;
   costGenerateScoreGs: opt nat;
   costGenerateScoreJuctrl: opt nat;
   costGenerateScoreJullm: opt nat;
   costIdleBurnRateChctrl: opt nat;
   costIdleBurnRateChllm: opt nat;
   costIdleBurnRateGs: opt nat;
   costIdleBurnRateJuctrl: opt nat;
   costIdleBurnRateJullm: opt nat;
   costIdleBurnRateMc: opt nat;
   costIdleBurnRateOwnctrl: opt nat;
   costIdleBurnRateOwnllm: opt nat;
   costIdleBurnRateSactrl: opt nat;
   costIdleBurnRateSallm: opt nat;
   costIdleBurnRateSsctrl: opt nat;
   costIdleBurnRateSsllm: opt nat;
   costUpgradeMainerCtrl: opt nat;
   costUpgradeMainerLlm: opt nat;
   costUpgradeMcMainerCtrl: opt nat;
   costUpgradeMcMainerLlm: opt nat;
   cyclesBurntChallengeGeneration: opt nat;
   cyclesBurntJudgeScoring: opt nat;
   cyclesBurntResponseGenerationOwn: opt nat;
   cyclesBurntResponseGenerationShare: opt nat;
   cyclesCreateMainerLlmTargetBalance: opt nat;
   cyclesCreateMainerMarginGs: opt nat;
   cyclesCreatemMainerMarginMc: opt nat;
   cyclesFailedSubmissionCut: opt nat;
   cyclesGenerateChallengeChctrlChllm: opt nat;
   cyclesGenerateChallengeGsChctrl: opt nat;
   cyclesGenerateResponseOwnctrlGs: opt nat;
   cyclesGenerateResponseOwnctrlOwnllmHIGH: opt nat;
   cyclesGenerateResponseOwnctrlOwnllmLOW: opt nat;
   cyclesGenerateResponseOwnctrlOwnllmMEDIUM: opt nat;
   cyclesGenerateResponseSactrlSsctrl: opt nat;
   cyclesGenerateResponseSsctrlGs: opt nat;
   cyclesGenerateResponseSsctrlSsllm: opt nat;
   cyclesGenerateScoreGsJuctrl: opt nat;
   cyclesGenerateScoreJuctrlJullm: opt nat;
   cyclesReinstallMainerctrlGsMc: opt nat;
   cyclesReinstallMainerctrlMcMainerctrl: opt nat;
   cyclesReinstallMainerllmGsMc: opt nat;
   cyclesReinstallMainerllmMcMainerllm: opt nat;
   cyclesSubmitResponse: opt nat;
   cyclesUpgradeMainerctrlGsMc: opt nat;
   cyclesUpgradeMainerctrlMcMainerctrl: opt nat;
   cyclesUpgradeMainerllmGsMc: opt nat;
   cyclesUpgradeMainerllmMcMainerllm: opt nat;
   dailyChallenges: opt nat;
   dailySubmissionsAllOwn: opt nat;
   dailySubmissionsAllShare: opt nat;
   dailySubmissionsPerOwnHIGH: opt nat;
   dailySubmissionsPerOwnLOW: opt nat;
   dailySubmissionsPerOwnMEDIUM: opt nat;
   dailySubmissionsPerShareHIGH: opt nat;
   dailySubmissionsPerShareLOW: opt nat;
   dailySubmissionsPerShareMEDIUM: opt nat;
   marginCost: opt nat;
   marginFailedSubmissionCut: opt nat;
   numChallengerLlms: opt nat;
   numJudgeLlms: opt nat;
   numShareServiceLlms: opt nat;
   protocolOperationFeesCut: opt nat;
   submissionFee: opt nat;
 };
type CyclesFlowResult = 
 variant {
   Err: ApiError;
   Ok: CyclesFlow;
 };
type CyclesFlow = 
 record {
   costCreateMainerCtrl: nat;
   costCreateMainerLlm: nat;
   costCreateMcMainerCtrl: nat;
   costCreateMcMainerLlm: nat;
   costGenerateChallengeChctrl: nat;
   costGenerateChallengeChllm: nat;
   costGenerateChallengeGs: nat;
   costGenerateResponseOwnGs: nat;
   costGenerateResponseOwnctrl: nat;
   costGenerateResponseOwnllm: nat;
   costGenerateResponseSactrl: nat;
   costGenerateResponseShareGs: nat;
   costGenerateResponseSsctrl: nat;
   costGenerateResponseSsllm: nat;
   costGenerateScoreGs: nat;
   costGenerateScoreJuctrl: nat;
   costGenerateScoreJullm: nat;
   costIdleBurnRateChctrl: nat;
   costIdleBurnRateChllm: nat;
   costIdleBurnRateGs: nat;
   costIdleBurnRateJuctrl: nat;
   costIdleBurnRateJullm: nat;
   costIdleBurnRateMc: nat;
   costIdleBurnRateOwnctrl: nat;
   costIdleBurnRateOwnllm: nat;
   costIdleBurnRateSactrl: nat;
   costIdleBurnRateSallm: nat;
   costIdleBurnRateSsctrl: nat;
   costIdleBurnRateSsllm: nat;
   costUpgradeMainerCtrl: nat;
   costUpgradeMainerLlm: nat;
   costUpgradeMcMainerCtrl: nat;
   costUpgradeMcMainerLlm: nat;
   cyclesBurntChallengeGeneration: nat;
   cyclesBurntJudgeScoring: nat;
   cyclesBurntResponseGenerationOwn: nat;
   cyclesBurntResponseGenerationShare: nat;
   cyclesCreateMainerLlmTargetBalance: nat;
   cyclesCreateMainerMarginGs: nat;
   cyclesCreatemMainerMarginMc: nat;
   cyclesFailedSubmissionCut: nat;
   cyclesGenerateChallengeChctrlChllm: nat;
   cyclesGenerateChallengeGsChctrl: nat;
   cyclesGenerateResponseOwnctrlGs: nat;
   cyclesGenerateResponseOwnctrlOwnllmHIGH: nat;
   cyclesGenerateResponseOwnctrlOwnllmLOW: nat;
   cyclesGenerateResponseOwnctrlOwnllmMEDIUM: nat;
   cyclesGenerateResponseSactrlSsctrl: nat;
   cyclesGenerateResponseSsctrlGs: nat;
   cyclesGenerateResponseSsctrlSsllm: nat;
   cyclesGenerateScoreGsJuctrl: nat;
   cyclesGenerateScoreJuctrlJullm: nat;
   cyclesSubmitResponse: nat;
   dailyChallenges: nat;
   dailySubmissionsAllOwn: nat;
   dailySubmissionsAllShare: nat;
   dailySubmissionsPerOwnHIGH: nat;
   dailySubmissionsPerOwnLOW: nat;
   dailySubmissionsPerOwnMEDIUM: nat;
   dailySubmissionsPerShareHIGH: nat;
   dailySubmissionsPerShareLOW: nat;
   dailySubmissionsPerShareMEDIUM: nat;
   marginCost: nat;
   marginFailedSubmissionCut: nat;
   numChallengerLlms: nat;
   numJudgeLlms: nat;
   numShareServiceLlms: nat;
   protocolOperationFeesCut: nat;
   submissionFee: nat;
 };
type CyclesBurntResult = 
 variant {
   Err: ApiError;
   Ok: nat;
 };
type CyclesBurnRateResult = 
 variant {
   Err: ApiError;
   Ok: CyclesBurnRate;
 };
type CyclesBurnRateDefault = 
 variant {
   Custom: CyclesBurnRate;
   High;
   Low;
   Mid;
   VeryHigh;
 };
type CyclesBurnRate = 
 record {
   cycles: nat;
   timeInterval: TimeInterval;
 };
type CheckMainerLimit = record {mainerType: MainerAgentCanisterType;};
type ChallengesResult = 
 variant {
   Err: ApiError;
   Ok: vec Challenge;
 };
type ChallengeWinnersResult = 
 variant {
   Err: ApiError;
   Ok: vec ChallengeWinnerDeclaration;
 };
type ChallengeWinnerReward = 
 record {
   amount: nat;
   distributed: bool;
   distributedTimestamp: opt nat64;
   rewardDetails: text;
   rewardType: RewardType;
 };
type ChallengeWinnerDeclaration = 
 record {
   challengeId: text;
   finalizedTimestamp: nat64;
   participants: List_1;
   secondPlace: ChallengeParticipantEntry;
   thirdPlace: ChallengeParticipantEntry;
   winner: ChallengeParticipantEntry;
 };
type ChallengeTopicStatus = 
 variant {
   Archived;
   Closed;
   Open;
   Other: text;
 };
type ChallengeTopicResult = 
 variant {
   Err: ApiError;
   Ok: ChallengeTopic;
 };
type ChallengeTopicInput = record {challengeTopic: text;};
type ChallengeTopic = 
 record {
   challengeTopic: text;
   challengeTopicCreationTimestamp: nat64;
   challengeTopicId: text;
   challengeTopicStatus: ChallengeTopicStatus;
   cyclesGenerateChallengeChctrlChllm: nat;
   cyclesGenerateChallengeGsChctrl: nat;
 };
type ChallengeStatus = 
 variant {
   Archived;
   Closed;
   Open;
   Other: text;
 };
type ChallengeResult = 
 variant {
   Err: ApiError;
   Ok: Challenge;
 };
type ChallengeResponseSubmissionsResult = 
 variant {
   Err: ApiError;
   Ok: vec ChallengeResponseSubmission;
 };
type ChallengeResponseSubmissionWithQueueStatusResult = 
 variant {
   Err: ApiError;
   Ok: ChallengeResponseSubmissionWithQueueStatus;
 };
type ChallengeResponseSubmissionWithQueueStatus = 
 record {
   remainingInQueue: nat;
   submission: ChallengeResponseSubmission;
 };
type ChallengeResponseSubmissionStatus = 
 variant {
   FailedSubmission;
   Judged;
   Judging;
   Other: text;
   Processed;
   Received;
   Submitted;
 };
type ChallengeResponseSubmissionMetadataResult = 
 variant {
   Err: ApiError;
   Ok: ChallengeResponseSubmissionMetadata;
 };
type ChallengeResponseSubmissionMetadata = 
 record {
   cyclesGenerateScoreGsJuctrl: nat;
   cyclesGenerateScoreJuctrlJullm: nat;
   submissionId: text;
   submissionStatus: ChallengeResponseSubmissionStatus;
   submittedTimestamp: nat64;
 };
type ChallengeResponseSubmissionInput = 
 record {
   challengeAnswer: text;
   challengeAnswerSeed: nat32;
   challengeClosedTimestamp: opt nat64;
   challengeCreatedBy: CanisterAddress;
   challengeCreationTimestamp: nat64;
   challengeId: text;
   challengeQuestion: text;
   challengeQuestionSeed: nat32;
   challengeQueuedBy: principal;
   challengeQueuedId: text;
   challengeQueuedTimestamp: nat64;
   challengeQueuedTo: principal;
   challengeStatus: ChallengeStatus;
   challengeTopic: text;
   challengeTopicCreationTimestamp: nat64;
   challengeTopicId: text;
   challengeTopicStatus: ChallengeTopicStatus;
   cyclesGenerateChallengeChctrlChllm: nat;
   cyclesGenerateChallengeGsChctrl: nat;
   cyclesGenerateResponseOwnctrlGs: nat;
   cyclesGenerateResponseOwnctrlOwnllmHIGH: nat;
   cyclesGenerateResponseOwnctrlOwnllmLOW: nat;
   cyclesGenerateResponseOwnctrlOwnllmMEDIUM: nat;
   cyclesGenerateResponseSactrlSsctrl: nat;
   cyclesGenerateResponseSsctrlGs: nat;
   cyclesGenerateResponseSsctrlSsllm: nat;
   cyclesSubmitResponse: nat;
   judgePromptId: text;
   mainerMaxContinueLoopCount: nat;
   mainerNumTokens: nat64;
   mainerPromptId: text;
   mainerTemp: float64;
   protocolOperationFeesCut: nat;
   submittedBy: principal;
 };
type ChallengeResponseSubmission = 
 record {
   challengeAnswer: text;
   challengeAnswerSeed: nat32;
   challengeClosedTimestamp: opt nat64;
   challengeCreatedBy: CanisterAddress;
   challengeCreationTimestamp: nat64;
   challengeId: text;
   challengeQuestion: text;
   challengeQuestionSeed: nat32;
   challengeQueuedBy: principal;
   challengeQueuedId: text;
   challengeQueuedTimestamp: nat64;
   challengeQueuedTo: principal;
   challengeStatus: ChallengeStatus;
   challengeTopic: text;
   challengeTopicCreationTimestamp: nat64;
   challengeTopicId: text;
   challengeTopicStatus: ChallengeTopicStatus;
   cyclesGenerateChallengeChctrlChllm: nat;
   cyclesGenerateChallengeGsChctrl: nat;
   cyclesGenerateResponseOwnctrlGs: nat;
   cyclesGenerateResponseOwnctrlOwnllmHIGH: nat;
   cyclesGenerateResponseOwnctrlOwnllmLOW: nat;
   cyclesGenerateResponseOwnctrlOwnllmMEDIUM: nat;
   cyclesGenerateResponseSactrlSsctrl: nat;
   cyclesGenerateResponseSsctrlGs: nat;
   cyclesGenerateResponseSsctrlSsllm: nat;
   cyclesGenerateScoreGsJuctrl: nat;
   cyclesGenerateScoreJuctrlJullm: nat;
   cyclesSubmitResponse: nat;
   judgePromptId: text;
   mainerMaxContinueLoopCount: nat;
   mainerNumTokens: nat64;
   mainerPromptId: text;
   mainerTemp: float64;
   protocolOperationFeesCut: nat;
   submissionId: text;
   submissionStatus: ChallengeResponseSubmissionStatus;
   submittedBy: principal;
   submittedTimestamp: nat64;
 };
type ChallengeParticipationResult = 
 variant {
   Other: text;
   Participated;
   SecondPlace;
   ThirdPlace;
   Winner;
 };
type ChallengeParticipantEntry = 
 record {
   ownedBy: principal;
   result: ChallengeParticipationResult;
   reward: ChallengeWinnerReward;
   submissionId: text;
   submittedBy: principal;
 };
type ChallengeAdditionResult = 
 variant {
   Err: ApiError;
   Ok: Challenge;
 };
type Challenge = 
 record {
   challengeClosedTimestamp: opt nat64;
   challengeCreatedBy: CanisterAddress;
   challengeCreationTimestamp: nat64;
   challengeId: text;
   challengeQuestion: text;
   challengeQuestionSeed: nat32;
   challengeStatus: ChallengeStatus;
   challengeTopic: text;
   challengeTopicCreationTimestamp: nat64;
   challengeTopicId: text;
   challengeTopicStatus: ChallengeTopicStatus;
   cyclesGenerateChallengeChctrlChllm: nat;
   cyclesGenerateChallengeGsChctrl: nat;
   cyclesGenerateResponseOwnctrlGs: nat;
   cyclesGenerateResponseOwnctrlOwnllmHIGH: nat;
   cyclesGenerateResponseOwnctrlOwnllmLOW: nat;
   cyclesGenerateResponseOwnctrlOwnllmMEDIUM: nat;
   cyclesGenerateResponseSactrlSsctrl: nat;
   cyclesGenerateResponseSsctrlGs: nat;
   cyclesGenerateResponseSsctrlSsllm: nat;
   cyclesSubmitResponse: nat;
   judgePromptId: text;
   mainerMaxContinueLoopCount: nat;
   mainerNumTokens: nat64;
   mainerPromptId: text;
   mainerTemp: float64;
   protocolOperationFeesCut: nat;
 };
type CanisterWasmHashRecordResult = 
 variant {
   Err: ApiError;
   Ok: CanisterWasmHashRecord;
 };
type CanisterWasmHashRecord = 
 record {
   createdBy: principal;
   creationTimestamp: nat64;
   textNote: text;
   version: nat;
   wasmHash: blob;
 };
type CanisterStatus = 
 variant {
   ControllerCreated;
   ControllerCreationInProgress;
   LlmSetupFinished;
   LlmSetupInProgress: LlmSetupStatus;
   Other: text;
   Paid;
   Paused;
   Running;
   Unlocked;
 };
type CanisterRetrieveInput = record {address: CanisterAddress;};
type CanisterInput = 
 record {
   address: CanisterAddress;
   canisterType: ProtocolCanisterType;
   subnet: text;
 };
type CanisterAddress = text;
type AuthRecordResult = 
 variant {
   Err: ApiError;
   Ok: AuthRecord;
 };
type AuthRecord = record {auth: text;};
type ApproveTokenResult = 
 variant {
   Err: ApproveTokenError;
   Ok: nat;
 };
type ApproveTokenError = 
 variant {
   CreatedInFuture: record {ledger_time: nat64;};
   Duplicate: record {duplicate_of: nat;};
   GenericBatchError: record {
                        error_code: nat;
                        message: text;
                      };
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   InvalidSpender;
   NonExistingTokenId;
   TooOld;
   Unauthorized;
 };
type ApproveTokenArg = 
 record {
   approval_info: ApprovalInfo;
   token_id: nat;
 };
type ApprovalInfo = 
 record {
   created_at_time: opt nat64;
   expires_at: opt nat64;
   from_subaccount: opt blob;
   memo: opt blob;
   spender: Account__1;
 };
type ApiError = 
 variant {
   FailedOperation;
   InsuffientCycles: nat;
   InvalidId;
   Other: text;
   StatusCode: StatusCode;
   Unauthorized;
   ZeroAddress;
 };
type AddCyclesResult = 
 variant {
   Err: ApiError;
   Ok: AddCyclesRecord;
 };
type AddCyclesRecord = 
 record {
   added: bool;
   amount: nat;
 };
type Account__1 = 
 record {
   owner: principal;
   subaccount: opt Subaccount;
 };
type Account = 
 record {
   owner: principal;
   subaccount: opt blob;
 };
service : () -> GameStateCanister
