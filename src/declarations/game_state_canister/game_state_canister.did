type UpdateWasmHashInput = 
 record {
   textNote: text;
   wasmHash: blob;
 };
type SubmissionRetrievalInput = 
 record {
   challengeId: text;
   submissionId: text;
 };
type StatusCodeRecordResult = 
 variant {
   Err: ApiError;
   Ok: StatusCodeRecord;
 };
type StatusCodeRecord = record {status_code: StatusCode;};
type StatusCode = nat16;
type SetUpMainerLlmCanisterResult = 
 variant {
   Err: ApiError;
   Ok:
    record {
      controllerCanisterEntry: OfficialMainerAgentCanister;
      llmCanisterId: text;
    };
 };
type SelectableMainerLLMs = variant {Qwen2_5_500M;};
type ScoredResponseReturn = record {success: bool;};
type ScoredResponseRetrievalResult = 
 variant {
   Err: ApiError;
   Ok: ScoredResponse;
 };
type ScoredResponseResult = 
 variant {
   Err: ApiError;
   Ok: ScoredResponseReturn;
 };
type ScoredResponseInput = 
 record {
   challengeAnswer: text;
   challengeAnswerSeed: nat32;
   challengeClosedTimestamp: opt nat64;
   challengeCreatedBy: CanisterAddress;
   challengeCreationTimestamp: nat64;
   challengeId: text;
   challengeQuestion: text;
   challengeQuestionSeed: nat32;
   challengeQueuedBy: principal;
   challengeQueuedId: text;
   challengeQueuedTimestamp: nat64;
   challengeQueuedTo: principal;
   challengeStatus: ChallengeStatus;
   challengeTopic: text;
   challengeTopicCreationTimestamp: nat64;
   challengeTopicId: text;
   challengeTopicStatus: ChallengeTopicStatus;
   judgedBy: principal;
   score: nat;
   scoreSeed: nat32;
   submissionCyclesRequired: nat;
   submissionId: text;
   submissionStatus: ChallengeResponseSubmissionStatus;
   submittedBy: principal;
   submittedTimestamp: nat64;
 };
type ScoredResponse = 
 record {
   challengeAnswer: text;
   challengeAnswerSeed: nat32;
   challengeClosedTimestamp: opt nat64;
   challengeCreatedBy: CanisterAddress;
   challengeCreationTimestamp: nat64;
   challengeId: text;
   challengeQuestion: text;
   challengeQuestionSeed: nat32;
   challengeQueuedBy: principal;
   challengeQueuedId: text;
   challengeQueuedTimestamp: nat64;
   challengeQueuedTo: principal;
   challengeStatus: ChallengeStatus;
   challengeTopic: text;
   challengeTopicCreationTimestamp: nat64;
   challengeTopicId: text;
   challengeTopicStatus: ChallengeTopicStatus;
   judgedBy: principal;
   judgedTimestamp: nat64;
   score: nat;
   scoreSeed: nat32;
   submissionCyclesRequired: nat;
   submissionId: text;
   submissionStatus: ChallengeResponseSubmissionStatus;
   submittedBy: principal;
   submittedTimestamp: nat64;
 };
type ScoredChallengesResult = 
 variant {
   Err: ApiError;
   Ok: vec record {
             text;
             List;
           };
 };
type RewardType = 
 variant {
   Coupon: text;
   Cycles;
   ICP;
   MainerToken;
   Other: text;
 };
type ProtocolCanisterType = 
 variant {
   Challenger;
   Judge;
   MainerAgent: MainerAgentCanisterType;
   MainerCreator;
   MainerLlm;
   Verifier;
 };
type ProtocolActivityResult = 
 variant {
   Err: ApiError;
   Ok: ProtocolActivityRecord;
 };
type ProtocolActivityRecord = 
 record {
   challenges: vec Challenge;
   winners: vec ChallengeWinnerDeclaration;
 };
type OfficialProtocolCanister = 
 record {
   address: CanisterAddress;
   canisterType: ProtocolCanisterType;
   createdBy: principal;
   creationTimestamp: nat64;
   ownedBy: principal;
   status: CanisterStatus;
 };
type OfficialMainerAgentCanister = 
 record {
   address: CanisterAddress;
   canisterType: ProtocolCanisterType;
   createdBy: principal;
   creationTimestamp: nat64;
   mainerConfig: MainerConfigurationInput;
   ownedBy: principal;
   status: CanisterStatus;
 };
type NewChallengeInput = 
 record {
   challengeQuestion: text;
   challengeQuestionSeed: nat32;
   challengeTopic: text;
   challengeTopicCreationTimestamp: nat64;
   challengeTopicId: text;
   challengeTopicStatus: ChallengeTopicStatus;
 };
type NatResult = 
 variant {
   Err: ApiError;
   Ok: nat;
 };
type MainerCreationInput = 
 record {
   mainerConfig: MainerConfigurationInput;
   owner: opt principal;
   paymentTransactionBlockId: nat64;
 };
type MainerConfigurationInput = 
 record {
   mainerAgentCanisterType: MainerAgentCanisterType;
   selectedLLM: opt SelectableMainerLLMs;
 };
type MainerAgentTopUpInput = 
 record {
   mainerAgent: OfficialMainerAgentCanister;
   paymentTransactionBlockId: nat64;
 };
type MainerAgentCanistersResult = 
 variant {
   Err: ApiError;
   Ok: vec OfficialMainerAgentCanister;
 };
type MainerAgentCanisterType = 
 variant {
   NA;
   Own;
   ShareAgent;
   ShareService;
 };
type MainerAgentCanisterResult = 
 variant {
   Err: ApiError;
   Ok: OfficialMainerAgentCanister;
 };
type LlmSetupStatus = 
 variant {
   CanisterCreated;
   CanisterCreationInProgress;
   CodeInstallInProgress;
   ConfigurationInProgress;
   ModelUploadProgress: nat8;
 };
type List_1 = 
 opt record {
       ChallengeParticipantEntry;
       List_1;
     };
type List = 
 opt record {
       ScoredResponse;
       List;
     };
type GameStateTresholdsResult = 
 variant {
   Err: ApiError;
   Ok: GameStateTresholds;
 };
type GameStateTresholds = 
 record {
   thresholdArchiveClosedChallenges: nat;
   thresholdMaxOpenChallenges: nat;
   thresholdMaxOpenSubmissions: nat;
   thresholdScoredResponsesPerChallenge: nat;
 };
type GameStateCanister = 
 service {
   addChallenge: (NewChallengeInput) -> (ChallengeAdditionResult);
   addChallengeTopic: (ChallengeTopicInput) -> (ChallengeTopicResult);
   addLlmCanisterToMainer: (OfficialMainerAgentCanister) ->
    (SetUpMainerLlmCanisterResult);
   addMainerAgentCanister: (OfficialMainerAgentCanister) ->
    (MainerAgentCanisterResult);
   addMainerAgentCanisterAdmin: (OfficialMainerAgentCanister) ->
    (MainerAgentCanisterResult);
   addOfficialCanister: (CanisterInput) -> (StatusCodeRecordResult);
   addScoredResponse: (ScoredResponseInput) -> (ScoredResponseResult);
   createUserMainerAgent: (MainerCreationInput) ->
    (MainerAgentCanisterResult);
   deriveNewMainerAgentCanisterWasmHashAdmin: (DeriveWasmHashInput) ->
    (CanisterWasmHashRecordResult);
   getCanisterPrincipal: () -> (text) query;
   getCurrentChallenges: () -> (ChallengesResult) query;
   getCurrentChallengesAdmin: () -> (ChallengesResult) query;
   getGameStateThresholdsAdmin: () -> (GameStateTresholdsResult) query;
   getMainerAgentCanisterInfo: (CanisterRetrieveInput) ->
    (MainerAgentCanisterResult) query;
   getMainerAgentCanistersForUser: () -> (MainerAgentCanistersResult) query;
   getNextSubmissionToJudge: () -> (ChallengeResponseSubmissionResult);
   getNumCurrentChallengesAdmin: () -> (NatResult) query;
   getNumOpenSubmissionsAdmin: () -> (NatResult) query;
   getNumScoredChallengesAdmin: () -> (NatResult) query;
   getNumSubmissionsAdmin: () -> (NatResult) query;
   getOfficialCanistersAdmin: () -> (vec OfficialProtocolCanister) query;
   getOfficialChallengerCanisters: () -> (AuthRecordResult);
   getOfficialSharedServiceCanisters: () -> (AuthRecordResult);
   getOpenSubmissionsAdmin: () -> (ChallengeResponseSubmissionsResult) query;
   getProtocolTotalCyclesBurnt: () -> (CyclesBurntResult) query;
   getRandomOpenChallenge: () -> (ChallengeResult);
   getRandomOpenChallengeTopic: () -> (ChallengeTopicResult);
   getRecentChallengeWinners: () -> (ChallengeWinnersResult) query;
   getRecentProtocolActivity: () -> (ProtocolActivityResult) query;
   getRecentProtocolActivity_mockup: () -> (ProtocolActivityResult) query;
   getScoreForSubmission: (SubmissionRetrievalInput) ->
    (ScoredResponseRetrievalResult) query;
   getScoreForSubmission_mockup: (SubmissionRetrievalInput) ->
    (ScoredResponseRetrievalResult) query;
   getScoredChallengesAdmin: () -> (ScoredChallengesResult) query;
   getSubmissionsAdmin: () -> (ChallengeResponseSubmissionsResult) query;
   health: () -> (StatusCodeRecordResult) query;
   removeOfficialSharedServiceCanisters: (text) -> (AuthRecordResult);
   setGameStateThresholdsAdmin: (GameStateTresholds) ->
    (StatusCodeRecordResult);
   setInitialChallengeTopics: () -> (StatusCodeRecordResult);
   setOfficialMainerAgentCanisterWasmHashAdmin: (UpdateWasmHashInput) ->
    (CanisterWasmHashRecordResult);
   setTokenLedgerCanisterId: (text) -> (AuthRecordResult);
   setUpMainerLlmCanister: (OfficialMainerAgentCanister) ->
    (SetUpMainerLlmCanisterResult);
   spinUpMainerControllerCanister: (OfficialMainerAgentCanister) ->
    (MainerAgentCanisterResult);
   submitChallengeResponse: (ChallengeResponseSubmissionInput) ->
    (ChallengeResponseSubmissionMetadataResult);
   testMainerCodeIntegrityAdmin: () -> (AuthRecordResult);
   testTokenMintingAdmin: () -> (AuthRecordResult);
   topUpCyclesForMainerAgent: (MainerAgentTopUpInput) ->
    (MainerAgentCanisterResult);
   unlockUserMainerAgent: (MainerCreationInput) ->
    (MainerAgentCanisterResult);
 };
type DeriveWasmHashInput = 
 record {
   address: CanisterAddress;
   textNote: text;
 };
type CyclesBurntResult = 
 variant {
   Err: ApiError;
   Ok: nat;
 };
type ChallengesResult = 
 variant {
   Err: ApiError;
   Ok: vec Challenge;
 };
type ChallengeWinnersResult = 
 variant {
   Err: ApiError;
   Ok: vec ChallengeWinnerDeclaration;
 };
type ChallengeWinnerReward = 
 record {
   amount: nat;
   distributed: bool;
   distributedTimestamp: opt nat64;
   rewardDetails: text;
   rewardType: RewardType;
 };
type ChallengeWinnerDeclaration = 
 record {
   challengeId: text;
   finalizedTimestamp: nat64;
   participants: List_1;
   secondPlace: ChallengeParticipantEntry;
   thirdPlace: ChallengeParticipantEntry;
   winner: ChallengeParticipantEntry;
 };
type ChallengeTopicStatus = 
 variant {
   Archived;
   Closed;
   Open;
   Other: text;
 };
type ChallengeTopicResult = 
 variant {
   Err: ApiError;
   Ok: ChallengeTopic;
 };
type ChallengeTopicInput = record {challengeTopic: text;};
type ChallengeTopic = 
 record {
   challengeTopic: text;
   challengeTopicCreationTimestamp: nat64;
   challengeTopicId: text;
   challengeTopicStatus: ChallengeTopicStatus;
 };
type ChallengeStatus = 
 variant {
   Archived;
   Closed;
   Open;
   Other: text;
 };
type ChallengeResult = 
 variant {
   Err: ApiError;
   Ok: Challenge;
 };
type ChallengeResponseSubmissionsResult = 
 variant {
   Err: ApiError;
   Ok: vec ChallengeResponseSubmission;
 };
type ChallengeResponseSubmissionStatus = 
 variant {
   FailedSubmission;
   Judged;
   Judging;
   Other: text;
   Processed;
   Received;
   Submitted;
 };
type ChallengeResponseSubmissionResult = 
 variant {
   Err: ApiError;
   Ok: ChallengeResponseSubmission;
 };
type ChallengeResponseSubmissionMetadataResult = 
 variant {
   Err: ApiError;
   Ok: ChallengeResponseSubmissionMetadata;
 };
type ChallengeResponseSubmissionMetadata = 
 record {
   submissionId: text;
   submissionStatus: ChallengeResponseSubmissionStatus;
   submittedTimestamp: nat64;
 };
type ChallengeResponseSubmissionInput = 
 record {
   challengeAnswer: text;
   challengeAnswerSeed: nat32;
   challengeClosedTimestamp: opt nat64;
   challengeCreatedBy: CanisterAddress;
   challengeCreationTimestamp: nat64;
   challengeId: text;
   challengeQuestion: text;
   challengeQuestionSeed: nat32;
   challengeQueuedBy: principal;
   challengeQueuedId: text;
   challengeQueuedTimestamp: nat64;
   challengeQueuedTo: principal;
   challengeStatus: ChallengeStatus;
   challengeTopic: text;
   challengeTopicCreationTimestamp: nat64;
   challengeTopicId: text;
   challengeTopicStatus: ChallengeTopicStatus;
   submissionCyclesRequired: nat;
   submittedBy: principal;
 };
type ChallengeResponseSubmission = 
 record {
   challengeAnswer: text;
   challengeAnswerSeed: nat32;
   challengeClosedTimestamp: opt nat64;
   challengeCreatedBy: CanisterAddress;
   challengeCreationTimestamp: nat64;
   challengeId: text;
   challengeQuestion: text;
   challengeQuestionSeed: nat32;
   challengeQueuedBy: principal;
   challengeQueuedId: text;
   challengeQueuedTimestamp: nat64;
   challengeQueuedTo: principal;
   challengeStatus: ChallengeStatus;
   challengeTopic: text;
   challengeTopicCreationTimestamp: nat64;
   challengeTopicId: text;
   challengeTopicStatus: ChallengeTopicStatus;
   submissionCyclesRequired: nat;
   submissionId: text;
   submissionStatus: ChallengeResponseSubmissionStatus;
   submittedBy: principal;
   submittedTimestamp: nat64;
 };
type ChallengeParticipationResult = 
 variant {
   Other: text;
   Participated;
   SecondPlace;
   ThirdPlace;
   Winner;
 };
type ChallengeParticipantEntry = 
 record {
   ownedBy: principal;
   result: ChallengeParticipationResult;
   reward: ChallengeWinnerReward;
   submissionId: text;
   submittedBy: principal;
 };
type ChallengeAdditionResult = 
 variant {
   Err: ApiError;
   Ok: Challenge;
 };
type Challenge = 
 record {
   challengeClosedTimestamp: opt nat64;
   challengeCreatedBy: CanisterAddress;
   challengeCreationTimestamp: nat64;
   challengeId: text;
   challengeQuestion: text;
   challengeQuestionSeed: nat32;
   challengeStatus: ChallengeStatus;
   challengeTopic: text;
   challengeTopicCreationTimestamp: nat64;
   challengeTopicId: text;
   challengeTopicStatus: ChallengeTopicStatus;
   submissionCyclesRequired: nat;
 };
type CanisterWasmHashRecordResult = 
 variant {
   Err: ApiError;
   Ok: CanisterWasmHashRecord;
 };
type CanisterWasmHashRecord = 
 record {
   createdBy: principal;
   creationTimestamp: nat64;
   textNote: text;
   version: nat;
   wasmHash: blob;
 };
type CanisterStatus = 
 variant {
   ControllerCreated;
   ControllerCreationInProgress;
   LlmSetupFinished;
   LlmSetupInProgress: LlmSetupStatus;
   Other: text;
   Paid;
   Paused;
   Running;
   Unlocked;
 };
type CanisterRetrieveInput = record {address: CanisterAddress;};
type CanisterInput = 
 record {
   address: CanisterAddress;
   canisterType: ProtocolCanisterType;
 };
type CanisterAddress = text;
type AuthRecordResult = 
 variant {
   Err: ApiError;
   Ok: AuthRecord;
 };
type AuthRecord = record {auth: text;};
type ApiError = 
 variant {
   FailedOperation;
   InsuffientCycles: nat;
   InvalidId;
   Other: text;
   StatusCode: StatusCode;
   Unauthorized;
   ZeroAddress;
 };
service : () -> GameStateCanister
